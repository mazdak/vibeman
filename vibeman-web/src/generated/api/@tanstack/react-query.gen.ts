// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getApiAiAttachByWorktree, getApiContainers, postApiContainers, deleteApiContainersById, getApiContainersById, postApiContainersByIdAction, getApiContainersByIdLogs, getApiServicesByIdLogs, getApiStatus, getApiWorktreesByIdLogs, getConfig, getHealth, getRepositories, postRepositories, deleteRepositoriesById, getServices, postServicesByIdStart, postServicesByIdStop, getWorktrees, postWorktrees, getWorktreesById, postWorktreesByIdStart, postWorktreesByIdStop } from '../sdk.gen';
import { queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { GetApiAiAttachByWorktreeData, GetApiContainersData, PostApiContainersData, PostApiContainersError, PostApiContainersResponse, DeleteApiContainersByIdData, DeleteApiContainersByIdError, DeleteApiContainersByIdResponse, GetApiContainersByIdData, PostApiContainersByIdActionData, PostApiContainersByIdActionError, PostApiContainersByIdActionResponse, GetApiContainersByIdLogsData, GetApiServicesByIdLogsData, GetApiStatusData, GetApiWorktreesByIdLogsData, GetConfigData, GetHealthData, GetRepositoriesData, PostRepositoriesData, PostRepositoriesError, PostRepositoriesResponse, DeleteRepositoriesByIdData, DeleteRepositoriesByIdError, DeleteRepositoriesByIdResponse, GetServicesData, PostServicesByIdStartData, PostServicesByIdStartError, PostServicesByIdStartResponse, PostServicesByIdStopData, PostServicesByIdStopError, PostServicesByIdStopResponse, GetWorktreesData, PostWorktreesData, PostWorktreesError, PostWorktreesResponse, GetWorktreesByIdData, PostWorktreesByIdStartData, PostWorktreesByIdStartError, PostWorktreesByIdStartResponse, PostWorktreesByIdStopData, PostWorktreesByIdStopError, PostWorktreesByIdStopResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getApiAiAttachByWorktreeQueryKey = (options: Options<GetApiAiAttachByWorktreeData>) => createQueryKey('getApiAiAttachByWorktree', options);

/**
 * WebSocket endpoint for AI container terminal
 * Establish WebSocket connection for terminal access to AI containers
 */
export const getApiAiAttachByWorktreeOptions = (options: Options<GetApiAiAttachByWorktreeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiAiAttachByWorktree({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiAiAttachByWorktreeQueryKey(options)
    });
};

export const getApiContainersQueryKey = (options?: Options<GetApiContainersData>) => createQueryKey('getApiContainers', options);

/**
 * List containers
 * Get a list of all containers
 */
export const getApiContainersOptions = (options?: Options<GetApiContainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiContainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiContainersQueryKey(options)
    });
};

export const postApiContainersQueryKey = (options: Options<PostApiContainersData>) => createQueryKey('postApiContainers', options);

/**
 * Create container
 * Create a new container
 */
export const postApiContainersOptions = (options: Options<PostApiContainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postApiContainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postApiContainersQueryKey(options)
    });
};

/**
 * Create container
 * Create a new container
 */
export const postApiContainersMutation = (options?: Partial<Options<PostApiContainersData>>): UseMutationOptions<PostApiContainersResponse, PostApiContainersError, Options<PostApiContainersData>> => {
    const mutationOptions: UseMutationOptions<PostApiContainersResponse, PostApiContainersError, Options<PostApiContainersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postApiContainers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete container
 * Delete a container by ID
 */
export const deleteApiContainersByIdMutation = (options?: Partial<Options<DeleteApiContainersByIdData>>): UseMutationOptions<DeleteApiContainersByIdResponse, DeleteApiContainersByIdError, Options<DeleteApiContainersByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiContainersByIdResponse, DeleteApiContainersByIdError, Options<DeleteApiContainersByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteApiContainersById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiContainersByIdQueryKey = (options: Options<GetApiContainersByIdData>) => createQueryKey('getApiContainersById', options);

/**
 * Get container by ID
 * Get a specific container by its ID
 */
export const getApiContainersByIdOptions = (options: Options<GetApiContainersByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiContainersById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiContainersByIdQueryKey(options)
    });
};

export const postApiContainersByIdActionQueryKey = (options: Options<PostApiContainersByIdActionData>) => createQueryKey('postApiContainersByIdAction', options);

/**
 * Perform action on container
 * Start, stop, or restart a container
 */
export const postApiContainersByIdActionOptions = (options: Options<PostApiContainersByIdActionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postApiContainersByIdAction({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postApiContainersByIdActionQueryKey(options)
    });
};

/**
 * Perform action on container
 * Start, stop, or restart a container
 */
export const postApiContainersByIdActionMutation = (options?: Partial<Options<PostApiContainersByIdActionData>>): UseMutationOptions<PostApiContainersByIdActionResponse, PostApiContainersByIdActionError, Options<PostApiContainersByIdActionData>> => {
    const mutationOptions: UseMutationOptions<PostApiContainersByIdActionResponse, PostApiContainersByIdActionError, Options<PostApiContainersByIdActionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postApiContainersByIdAction({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiContainersByIdLogsQueryKey = (options: Options<GetApiContainersByIdLogsData>) => createQueryKey('getApiContainersByIdLogs', options);

/**
 * Get container logs
 * Get logs from a container
 */
export const getApiContainersByIdLogsOptions = (options: Options<GetApiContainersByIdLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiContainersByIdLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiContainersByIdLogsQueryKey(options)
    });
};

export const getApiServicesByIdLogsQueryKey = (options: Options<GetApiServicesByIdLogsData>) => createQueryKey('getApiServicesByIdLogs', options);

/**
 * Get service logs
 * Get logs from a specific service
 */
export const getApiServicesByIdLogsOptions = (options: Options<GetApiServicesByIdLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiServicesByIdLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiServicesByIdLogsQueryKey(options)
    });
};

export const getApiStatusQueryKey = (options?: Options<GetApiStatusData>) => createQueryKey('getApiStatus', options);

/**
 * System status
 * Get comprehensive system status including service health and resource counts
 */
export const getApiStatusOptions = (options?: Options<GetApiStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiStatusQueryKey(options)
    });
};

export const getApiWorktreesByIdLogsQueryKey = (options: Options<GetApiWorktreesByIdLogsData>) => createQueryKey('getApiWorktreesByIdLogs', options);

/**
 * Get worktree logs
 * Get logs from a specific worktree
 */
export const getApiWorktreesByIdLogsOptions = (options: Options<GetApiWorktreesByIdLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiWorktreesByIdLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiWorktreesByIdLogsQueryKey(options)
    });
};

export const getConfigQueryKey = (options?: Options<GetConfigData>) => createQueryKey('getConfig', options);

/**
 * Get global configuration
 * Get the global Vibeman configuration
 */
export const getConfigOptions = (options?: Options<GetConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getConfigQueryKey(options)
    });
};

export const getHealthQueryKey = (options?: Options<GetHealthData>) => createQueryKey('getHealth', options);

/**
 * Health check
 * Check if the API is healthy
 */
export const getHealthOptions = (options?: Options<GetHealthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHealth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHealthQueryKey(options)
    });
};

export const getRepositoriesQueryKey = (options?: Options<GetRepositoriesData>) => createQueryKey('getRepositories', options);

/**
 * List repositories
 * Get a list of tracked repositories
 */
export const getRepositoriesOptions = (options?: Options<GetRepositoriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositories({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoriesQueryKey(options)
    });
};

export const postRepositoriesQueryKey = (options: Options<PostRepositoriesData>) => createQueryKey('postRepositories', options);

/**
 * Add a repository
 * Add a repository to the tracked list
 */
export const postRepositoriesOptions = (options: Options<PostRepositoriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postRepositories({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postRepositoriesQueryKey(options)
    });
};

/**
 * Add a repository
 * Add a repository to the tracked list
 */
export const postRepositoriesMutation = (options?: Partial<Options<PostRepositoriesData>>): UseMutationOptions<PostRepositoriesResponse, PostRepositoriesError, Options<PostRepositoriesData>> => {
    const mutationOptions: UseMutationOptions<PostRepositoriesResponse, PostRepositoriesError, Options<PostRepositoriesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postRepositories({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a repository
 * Stop tracking a repository (doesn't delete files)
 */
export const deleteRepositoriesByIdMutation = (options?: Partial<Options<DeleteRepositoriesByIdData>>): UseMutationOptions<DeleteRepositoriesByIdResponse, DeleteRepositoriesByIdError, Options<DeleteRepositoriesByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteRepositoriesByIdResponse, DeleteRepositoriesByIdError, Options<DeleteRepositoriesByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRepositoriesById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getServicesQueryKey = (options?: Options<GetServicesData>) => createQueryKey('getServices', options);

/**
 * List services
 * Get a list of available services
 */
export const getServicesOptions = (options?: Options<GetServicesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getServices({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getServicesQueryKey(options)
    });
};

export const postServicesByIdStartQueryKey = (options: Options<PostServicesByIdStartData>) => createQueryKey('postServicesByIdStart', options);

/**
 * Start a service
 * Start a specific service by ID
 */
export const postServicesByIdStartOptions = (options: Options<PostServicesByIdStartData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postServicesByIdStart({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postServicesByIdStartQueryKey(options)
    });
};

/**
 * Start a service
 * Start a specific service by ID
 */
export const postServicesByIdStartMutation = (options?: Partial<Options<PostServicesByIdStartData>>): UseMutationOptions<PostServicesByIdStartResponse, PostServicesByIdStartError, Options<PostServicesByIdStartData>> => {
    const mutationOptions: UseMutationOptions<PostServicesByIdStartResponse, PostServicesByIdStartError, Options<PostServicesByIdStartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postServicesByIdStart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postServicesByIdStopQueryKey = (options: Options<PostServicesByIdStopData>) => createQueryKey('postServicesByIdStop', options);

/**
 * Stop a service
 * Stop a specific service by ID
 */
export const postServicesByIdStopOptions = (options: Options<PostServicesByIdStopData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postServicesByIdStop({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postServicesByIdStopQueryKey(options)
    });
};

/**
 * Stop a service
 * Stop a specific service by ID
 */
export const postServicesByIdStopMutation = (options?: Partial<Options<PostServicesByIdStopData>>): UseMutationOptions<PostServicesByIdStopResponse, PostServicesByIdStopError, Options<PostServicesByIdStopData>> => {
    const mutationOptions: UseMutationOptions<PostServicesByIdStopResponse, PostServicesByIdStopError, Options<PostServicesByIdStopData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postServicesByIdStop({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorktreesQueryKey = (options?: Options<GetWorktreesData>) => createQueryKey('getWorktrees', options);

/**
 * List worktrees
 * Get a list of worktrees with optional filters
 */
export const getWorktreesOptions = (options?: Options<GetWorktreesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorktrees({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorktreesQueryKey(options)
    });
};

export const postWorktreesQueryKey = (options: Options<PostWorktreesData>) => createQueryKey('postWorktrees', options);

/**
 * Create a new worktree
 * Create a new development worktree for a repository
 */
export const postWorktreesOptions = (options: Options<PostWorktreesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postWorktrees({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postWorktreesQueryKey(options)
    });
};

/**
 * Create a new worktree
 * Create a new development worktree for a repository
 */
export const postWorktreesMutation = (options?: Partial<Options<PostWorktreesData>>): UseMutationOptions<PostWorktreesResponse, PostWorktreesError, Options<PostWorktreesData>> => {
    const mutationOptions: UseMutationOptions<PostWorktreesResponse, PostWorktreesError, Options<PostWorktreesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postWorktrees({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorktreesByIdQueryKey = (options: Options<GetWorktreesByIdData>) => createQueryKey('getWorktreesById', options);

/**
 * Get worktree by ID
 * Get a specific worktree by its ID
 */
export const getWorktreesByIdOptions = (options: Options<GetWorktreesByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorktreesById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorktreesByIdQueryKey(options)
    });
};

export const postWorktreesByIdStartQueryKey = (options: Options<PostWorktreesByIdStartData>) => createQueryKey('postWorktreesByIdStart', options);

/**
 * Start a worktree
 * Start a stopped worktree and its associated container
 */
export const postWorktreesByIdStartOptions = (options: Options<PostWorktreesByIdStartData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postWorktreesByIdStart({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postWorktreesByIdStartQueryKey(options)
    });
};

/**
 * Start a worktree
 * Start a stopped worktree and its associated container
 */
export const postWorktreesByIdStartMutation = (options?: Partial<Options<PostWorktreesByIdStartData>>): UseMutationOptions<PostWorktreesByIdStartResponse, PostWorktreesByIdStartError, Options<PostWorktreesByIdStartData>> => {
    const mutationOptions: UseMutationOptions<PostWorktreesByIdStartResponse, PostWorktreesByIdStartError, Options<PostWorktreesByIdStartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postWorktreesByIdStart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postWorktreesByIdStopQueryKey = (options: Options<PostWorktreesByIdStopData>) => createQueryKey('postWorktreesByIdStop', options);

/**
 * Stop a worktree
 * Stop a running worktree and its associated container
 */
export const postWorktreesByIdStopOptions = (options: Options<PostWorktreesByIdStopData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postWorktreesByIdStop({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postWorktreesByIdStopQueryKey(options)
    });
};

/**
 * Stop a worktree
 * Stop a running worktree and its associated container
 */
export const postWorktreesByIdStopMutation = (options?: Partial<Options<PostWorktreesByIdStopData>>): UseMutationOptions<PostWorktreesByIdStopResponse, PostWorktreesByIdStopError, Options<PostWorktreesByIdStopData>> => {
    const mutationOptions: UseMutationOptions<PostWorktreesByIdStopResponse, PostWorktreesByIdStopError, Options<PostWorktreesByIdStopData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postWorktreesByIdStop({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};